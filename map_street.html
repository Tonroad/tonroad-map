<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <title>TonRoad Street View</title>
  <meta name="viewport" content="width=device-width,initial-scale=1.0" />
  <style>
    html, body {
      margin:0; padding:0; height:100%;
      font-family:Arial,sans-serif; background:#2c3e50; color:#ecf0f1;
    }
    body { min-height:100vh; }
    #cityRow {
      display:flex; align-items:center; justify-content:flex-start;
      margin: 8px 0 4px 0; z-index:1100; position:relative;
    }
    #cityLabel { font-size:18px; font-weight:bold; margin-right:8px; }
    #citySelect {
      font-size:16px; padding:5px 12px; border-radius:7px; border:none;
      background:#26963a; color:#fff; font-weight:bold;
      margin-right:12px;
    }
    #topPanel {
      display:flex; gap:8px; align-items:center; margin: 6px 0 2px 0;
      z-index:1002; position:relative;
    }
    .mode-label {
      background:#d21; color:#fff; padding:7px 18px; border-radius:6px;
      font-size:19px; font-weight:bold; letter-spacing:1px;
    }
    #voteResults {
      background:rgba(32,32,32,0.90); padding:7px 16px; border-radius:6px;
      font-size:18px; font-weight:bold; margin-left:8px;
      min-width:220px; text-align:center; letter-spacing:1px;
    }
    #mapWrap {
      width:100%; position:relative; height:0; z-index:1000;
    }
    #mapPopup {
      display:none; position:fixed; top:0; left:0; width:100vw; height:48vh;
      background:#151f27; border-bottom:5px solid #27e682; z-index:1000;
      box-shadow: 0 10px 24px 0 #0008;
      transition: transform 0.33s;
    }
    #mapPopup.active { display:block; }
    #mapBtnShow {
      display:inline-block; margin:10px auto 0 auto; font-size:19px;
      background:#29caa8; color:#161c27; font-weight:bold;
      border:none; border-radius:22px; padding:15px 32px; cursor:pointer;
      z-index:1101; position:relative;
      box-shadow:0 2px 8px #0004;
    }
    #mapBtnHide {
      display:block; margin:18px auto 6px auto; font-size:29px;
      background:#21e181; color:#191c27; font-weight:bold; border:none;
      border-radius:25px; padding:18px 48px; cursor:pointer;
      box-shadow:0 2px 10px #0003;
    }
    #map {
      width:96vw; height:32vh; margin:0 auto; border-radius:12px;
      box-shadow:0 2px 16px #0004; border:3px solid #19c799;
    }
    #street-view {
      height:43vh; width:100vw; max-width:100vw;
      position:relative; margin:0; border:none;
    }
    .vote-btn-row, .action-btn-row {
      display:flex; flex-direction:row; gap:10px; margin:0; width:100%;
      justify-content:center; margin-top:10px; margin-bottom:0;
    }
    .vote-btn-row button {
      flex:1 1 0; min-width:0;
      font-size:24px; font-weight:bold; letter-spacing:1px;
      padding:16px 0; border-radius:12px; border:none; color:#fff;
      box-shadow:0 2px 6px #0004;
      margin:0; background:#1859b4; cursor:pointer;
      transition:background .15s;
    }
    .vote-btn-row button[data-dir="left"] { background:#3465d4; }
    .vote-btn-row button[data-dir="straight"] { background:#32b566; }
    .vote-btn-row button[data-dir="right"] { background:#f2ae28; color:#181818;}
    .vote-btn-row button:active { background:#1a314b; color:#eee; }
    .action-btn-row button {
      flex:1 1 0; min-width:0;
      font-size:23px; font-weight:bold; letter-spacing:1px;
      padding:13px 0; border-radius:12px; border:none; color:#fff;
      box-shadow:0 2px 7px #0002; margin:0; margin-bottom:10px;
      cursor:pointer; transition:background .15s;
    }
    .action-btn-row .start { background:#269fff; }
    .action-btn-row .drive { background:#29e166; color:#112; }
    .action-btn-row .back { background:#fa8c1e; }
    .action-btn-row .radio { background:#2e9ef7; }
    .action-btn-row .mapshow { background:#2e9ef7; }
    #timerLabel {
      font-size:22px; background:#232b38; color:#fff; border-radius:6px;
      padding:7px 20px; margin:6px 0; display:block; width:fit-content;
      margin-left:auto; margin-right:auto; font-weight:bold;
      letter-spacing:1px;
    }
    @media (max-width: 600px) {
      #street-view { height: 33vh; }
      #mapPopup { height:38vh; }
      #map { height:25vh; }
      .vote-btn-row button, .action-btn-row button { font-size:18px; padding:11px 0;}
      #voteResults { font-size:15px; min-width:140px;}
    }
  </style>
  <script src="https://telegram.org/js/telegram-web-app.js"></script>
  <script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyDLtao0F3Xm136OwD-LFglwhpBdOB6sht8" async defer></script>
</head>
<body>
  <div id="cityRow">
    <span id="cityLabel">–ì–æ—Ä–æ–¥:</span>
    <select id="citySelect">
      <option value="Berlin">–ë–µ—Ä–ª–∏–Ω</option>
      <option value="Leipzig">–õ–µ–π–ø—Ü–∏–≥</option>
      <option value="Dresden">–î—Ä–µ–∑–¥–µ–Ω</option>
      <option value="Novorossiysk">–ù–æ–≤–æ—Ä–æ—Å—Å–∏–π—Å–∫</option>
    </select>
  </div>
  <div id="topPanel">
    <span class="mode-label">–†–µ–∂–∏–º: –ì–æ–ª–æ—Å–æ–≤–∞–Ω–∏–µ</span>
    <span id="voteResults">–í–ª–µ–≤–æ: 0 | –ü—Ä—è–º–æ: 0 | –í–ø—Ä–∞–≤–æ: 0</span>
  </div>
  <div id="mapWrap">
    <button id="mapBtnShow" onclick="toggleMapPopup(true)">–ü–æ–∫–∞–∑–∞—Ç—å –∫–∞—Ä—Ç—É ‚ñº</button>
    <div id="mapPopup">
      <button id="mapBtnHide" onclick="toggleMapPopup(false)">–°–∫—Ä—ã—Ç—å –∫–∞—Ä—Ç—É ‚ñ≤</button>
      <div id="map"></div>
    </div>
  </div>
  <div id="street-view"></div>
  <span id="timerLabel" style="display:none"></span>

  <!-- –ö–ù–û–ü–ö–ò –≤ –¥–≤–∞ —Ä—è–¥–∞ -->
  <div class="vote-btn-row">
    <button data-dir="left">‚Üê –í–ª–µ–≤–æ</button>
    <button data-dir="straight">‚Üë –ü—Ä—è–º–æ</button>
    <button data-dir="right">‚Üí –í–ø—Ä–∞–≤–æ</button>
  </div>
  <div class="action-btn-row">
    <button class="start">–°—Ç–∞—Ä—Ç</button>
    <button class="drive">–ï–•–ê–¢–¨</button>
    <button class="back">–ù–∞–∑–∞–¥</button>
    <button class="radio" onclick="window.open('https://t.me/fmusbot','_blank')">üéµ –†–∞–¥–∏–æ</button>
    <button class="mapshow" onclick="toggleMapPopup(true)">–ö–∞—Ä—Ç–∞</button>
  </div>

  <script>
    // --- –ö–û–ù–§–ò–ì ---
    const LEADER_ID = "5959529178"; // <== –ó–∞–º–µ–Ω–∏—Ç—å –Ω–∞ —Å–≤–æ–π Telegram ID!
    const API_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InFzZGFvb3h5d3pubG9vZ3loZXl1Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTIwMDAyMzIsImV4cCI6MjA2NzU3NjIzMn0.t2wjdhhV_RfaB3aVQqDai546h5xNNBZpEu_lnrkL8Do";
    const BASE_URL = "https://qsdaooxywznloogyheyu.supabase.co";

    // --- –ì–õ–û–ë–ê–õ–¨–ù–´–ï ---
    let routeHistory = []; // –º–∞—Ä—à—Ä—É—Ç –¥–ª—è –∫–∞—Ä—Ç—ã

    // --- –ü–û–õ–¨–ó–û–í–ê–¢–ï–õ–¨ / –õ–ò–î–ï–† ---
    let tgUserId = null;
    try {
      Telegram.WebApp.ready();
      if (Telegram.WebApp.initDataUnsafe && Telegram.WebApp.initDataUnsafe.user)
        tgUserId = String(Telegram.WebApp.initDataUnsafe.user.id);
    } catch {}
    if (!tgUserId && window.location.search.match(/user=(\d+)/)) {
      tgUserId = window.location.search.match(/user=(\d+)/)[1];
    }
    function isLeader() {
      return String(tgUserId) === LEADER_ID;
    }

    // --- –í–´–ü–ê–î–ê–Æ–©–ê–Ø –ö–ê–†–¢–ê ---
    function toggleMapPopup(show) {
      const popup = document.getElementById('mapPopup');
      if (show) popup.classList.add('active');
      else popup.classList.remove('active');
    }

    window.onload = () => {
      Telegram.WebApp.ready();
      initApp();
    };

    function initApp() {
      let timerInterval = null;

      class MapManager {
        constructor(mapEl, streetEl, cities) {
          this.cities = cities;
          this.routePath = null;
          this.map = new google.maps.Map(mapEl, {
            center: cities.Berlin,
            zoom: 15,
            disableDefaultUI: true
          });
          this.street = new google.maps.StreetViewPanorama(streetEl, {
            position: cities.Berlin, pov: { heading: 0, pitch: 0 }, visible: true
          });
          this.map.setStreetView(this.street);
          this.polyline = null;
        }
        setCity(cityKey) {
          const pos = this.cities[cityKey];
          this.map.setCenter(pos);
          this.street.setPosition(pos);
        }
        async loadPositionFromServer(city) {
          const url = `${BASE_URL}/rest/v1/current_position?city=eq.${city}&select=lat,lng,heading&limit=1`;
          const response = await fetch(url, { headers: { apikey: API_KEY } });
          const data = await response.json();
          if (data.length) {
            const { lat, lng, heading } = data[0];
            this.street.setPosition({ lat, lng });
            this.street.setPov({ heading, pitch: 0 });
            // –¥–æ–±–∞–≤–ª—è–µ–º —Ç–æ—á–∫—É –≤ –º–∞—Ä—à—Ä—É—Ç, –µ—Å–ª–∏ –Ω–æ–≤–∞—è
            if (!routeHistory.length || Math.abs(lat-routeHistory[routeHistory.length-1].lat)>1e-6 || Math.abs(lng-routeHistory[routeHistory.length-1].lng)>1e-6)
              routeHistory.push({lat, lng});
            this.drawRoute();
          }
        }
        async savePositionToServer(city) {
          const pos = this.getPosition();
          await fetch(`${BASE_URL}/rest/v1/current_position?city=eq.${city}`, {
            method: "PATCH",
            headers: { apikey: API_KEY, "Content-Type": "application/json" },
            body: JSON.stringify({ lat: pos.lat, lng: pos.lng, heading: pos.heading })
          });
        }
        getPosition() {
          const pos = this.street.getPosition();
          const heading = this.street.getPov().heading;
          return { lat: pos.lat(), lng: pos.lng(), heading };
        }
        findBestLink(dir) {
          const pov = this.street.getPov().heading;
          const links = this.street.getLinks() || [];
          const want = { straight: 0, left: 270, right: 90 }[dir];
          let best = { diff: Infinity, link: null };
          links.forEach(link => {
            let rel = (link.heading - pov + 360) % 360;
            let diff = Math.abs(rel - want);
            diff = Math.min(diff, 360 - diff);
            if (diff < best.diff) best = { diff, link };
          });
          if (!best.link) throw new Error('–ù–µ—Ç –ø–æ–¥—Ö–æ–¥—è—â–µ–≥–æ –ø–æ–≤–æ—Ä–æ—Ç–∞');
          return best.link;
        }
        async saveNextPositionToServer(city, dir) {
          try {
            const link = this.findBestLink(dir);
            const svService = new google.maps.StreetViewService();
            svService.getPanorama({ pano: link.pano }, async (data, status) => {
              if (status === google.maps.StreetViewStatus.OK) {
                const nextLatLng = data.location.latLng;
                await fetch(`${BASE_URL}/rest/v1/current_position?city=eq.${city}`, {
                  method: "PATCH",
                  headers: { apikey: API_KEY, "Content-Type": "application/json" },
                  body: JSON.stringify({
                    next_lat: nextLatLng.lat(),
                    next_lng: nextLatLng.lng(),
                    next_heading: link.heading
                  })
                });
              }
            });
          } catch (e) {}
        }
        async loadNextPositionFromServer(city) {
          const url = `${BASE_URL}/rest/v1/current_position?city=eq.${city}&select=next_lat,next_lng,next_heading&limit=1`;
          const response = await fetch(url, { headers: { apikey: API_KEY } });
          const data = await response.json();
          if (data.length && data[0].next_lat && data[0].next_lng && data[0].next_heading !== undefined) {
            return {
              lat: data[0].next_lat,
              lng: data[0].next_lng,
              heading: data[0].next_heading
            };
          }
          return null;
        }
        async goToNextPosition(city) {
          const next = await this.loadNextPositionFromServer(city);
          if (!next) return false;
          this.street.setPosition({ lat: next.lat, lng: next.lng });
          this.street.setPov({ heading: next.heading, pitch: 0 });
          routeHistory.push({ lat: next.lat, lng: next.lng });
          this.drawRoute();
          await fetch(`${BASE_URL}/rest/v1/current_position?city=eq.${city}`, {
            method: "PATCH",
            headers: { apikey: API_KEY, "Content-Type": "application/json" },
            body: JSON.stringify({
              lat: next.lat, lng: next.lng, heading: next.heading
            })
          });
          return true;
        }
        async resetToStart(city) {
          const pos = this.cities[city];
          this.street.setPosition(pos);
          this.street.setPov({ heading: 0, pitch: 0 });
          routeHistory = [pos];
          this.drawRoute();
          await fetch(`${BASE_URL}/rest/v1/current_position?city=eq.${city}`, {
            method: "PATCH",
            headers: { apikey: API_KEY, "Content-Type": "application/json" },
            body: JSON.stringify({ lat: pos.lat, lng: pos.lng, heading: 0 })
          });
        }
        // –†–∏—Å—É–µ–º –º–∞—Ä—à—Ä—É—Ç
        drawRoute() {
          if (!this.polyline) {
            this.polyline = new google.maps.Polyline({
              path: routeHistory, geodesic: true,
              strokeColor: "#28f", strokeOpacity: 0.9, strokeWeight: 5,
              map: this.map
            });
          }
          this.polyline.setPath(routeHistory);
          if (routeHistory.length)
            this.map.setCenter(routeHistory[routeHistory.length-1]);
        }
      }

      class VoteManager {
        constructor(city, mode, displayEl, onVoteChange) {
          this.city = city;
          this.mode = mode;
          this.displayEl = displayEl;
          this.votes = { left: 0, straight: 0, right: 0 };
          this.onVoteChange = onVoteChange;
        }
        async load() {
          const url = `${BASE_URL}/rest/v1/votes_summary?select=direction,count&city=eq.${this.city}&mode=eq.${this.mode}`;
          const res = await fetch(url, { headers: { apikey: API_KEY } });
          const data = await res.json();
          this.votes = { left: 0, straight: 0, right: 0 };
          data.forEach(v => this.votes[v.direction] = v.count);
          this.updateDisplay();
          if (this.onVoteChange) this.onVoteChange(this.votes);
        }
        async vote(dir) {
          this.votes[dir]++;
          this.updateDisplay();
          if (this.onVoteChange) this.onVoteChange(this.votes);
          await fetch(`${BASE_URL}/functions/v1/cast_vote-ts`, {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              apikey: API_KEY,
              Authorization: `Bearer ${API_KEY}`
            },
            body: JSON.stringify({ city: this.city, mode: this.mode, direction: dir })
          });
        }
        async resetOnServer() {
          await fetch(`${BASE_URL}/rest/v1/votes_summary?city=eq.${this.city}&mode=eq.${this.mode}`, {
            method: "PATCH",
            headers: {
              apikey: API_KEY,
              "Content-Type": "application/json"
            },
            body: JSON.stringify({ count: 0 })
          });
        }
        updateDisplay() {
          this.displayEl.textContent = `–í–ª–µ–≤–æ: ${this.votes.left} | –ü—Ä—è–º–æ: ${this.votes.straight} | –í–ø—Ä–∞–≤–æ: ${this.votes.right}`;
        }
        resetLocal() {
          this.votes = { left: 0, straight: 0, right: 0 };
          this.updateDisplay();
        }
      }

      // --- –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø ---
      const cities = {
        Berlin: { lat: 52.52, lng: 13.405 },
        Leipzig: { lat: 51.3397, lng: 12.3731 },
        Dresden: { lat: 51.0504, lng: 13.7373 },
        Novorossiysk: { lat: 44.7236, lng: 37.7689 }
      };
      let selectedCity = localStorage.getItem("selectedCity") || "Berlin";
      document.getElementById('citySelect').value = selectedCity;

      // --- –°–õ–ï–î–ò–ú –ó–ê –í–´–ë–û–†–û–ú –ì–û–†–û–î–ê ---
      document.getElementById('citySelect').addEventListener('change', async e => {
        selectedCity = e.target.value;
        localStorage.setItem("selectedCity", selectedCity);
        await mapMgr.loadPositionFromServer(selectedCity);
        await voteMgr.load();
      });

      // --- –ö–ê–†–¢–ê –∏ STREET VIEW ---
      let mapMgr = null, voteMgr = null;
      function onGoogleMapsReady() {
        mapMgr = new MapManager(document.getElementById('map'), document.getElementById('street-view'), cities);
        voteMgr = new VoteManager(selectedCity, "voting", document.getElementById('voteResults'), handleVoteChange);
        mapMgr.loadPositionFromServer(selectedCity);
        voteMgr.load();
      }
      let mapsLoaded = false;
      function waitMapsReady() {
        if (window.google && window.google.maps) { onGoogleMapsReady(); mapsLoaded=true; }
        else setTimeout(waitMapsReady, 400);
      }
      waitMapsReady();

      // --- –ö–ù–û–ü–ö–ò ---
      document.querySelectorAll('.vote-btn-row button').forEach(btn =>
        btn.addEventListener('click', () => voteMgr.vote(btn.dataset.dir))
      );
      document.querySelector('.start').addEventListener('click', async () => {
        await mapMgr.resetToStart(selectedCity);
        voteMgr.resetLocal();
      });
      document.querySelector('.drive').addEventListener('click', async () => {
        if (!isLeader()) return;
        await drive();
      });
      document.querySelector('.back').addEventListener('click', () => {
        Telegram.WebApp.close();
      });

      // --- –¢–û–õ–¨–ö–û –≤–µ–¥—É—â–∏–π –≤–∏–¥–∏—Ç –∫–Ω–æ–ø–∫—É –ï–•–ê–¢–¨ ---
      function updateDriveButton() {
        const driveBtn = document.querySelector('.drive');
        if (isLeader()) driveBtn.style.display = "";
        else driveBtn.style.display = "none";
      }
      updateDriveButton();

      // --- –û–ë–†–ê–ë–û–¢–ö–ê –ì–û–õ–û–°–û–í ---
      let timerValue = 0, timerActive = false, timerInterval = null;
      async function handleVoteChange(votes) {
        const total = Object.values(votes).reduce((a, b) => a + b, 0);
        if (total === 0) { resetTimer(); return; }
        const maxDir = Object.keys(votes).reduce((a, b) => votes[a] > votes[b] ? a : b);
        await mapMgr.saveNextPositionToServer(selectedCity, maxDir);
        // –ï—Å–ª–∏ —Ç–∞–π–º–µ—Ä –Ω–µ –±—ã–ª –∞–∫—Ç–∏–≤–µ–Ω ‚Äî —Å—Ç–∞—Ä—Ç—É–µ–º!
        if (!timerActive) startTimer();
      }
      function startTimer() {
        timerValue = 5;
        timerActive = true;
        const timerLbl = document.getElementById('timerLabel');
        timerLbl.style.display = "";
        timerLbl.textContent = `–ü–æ–µ–¥–µ–º —á–µ—Ä–µ–∑: ${timerValue} —Å–µ–∫`;
        timerInterval = setInterval(() => {
          timerValue--;
          timerLbl.textContent = `–ü–æ–µ–¥–µ–º —á–µ—Ä–µ–∑: ${timerValue} —Å–µ–∫`;
          if (timerValue <= 0) drive();
        }, 1000);
      }
      function resetTimer() {
        if (timerInterval) clearInterval(timerInterval);
        timerActive = false;
        timerValue = 0;
        document.getElementById('timerLabel').style.display = "none";
      }
      async function drive() {
        resetTimer();
        const moved = await mapMgr.goToNextPosition(selectedCity);
        if (!moved) {
          voteMgr.displayEl.textContent = '–ù–µ—Ç –±—É–¥—É—â–µ–π –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –¥–ª—è –¥–≤–∏–∂–µ–Ω–∏—è';
          return;
        }
        voteMgr.displayEl.textContent = `–ü–æ–µ—Ö–∞–ª–∏!`;
        await voteMgr.resetOnServer();
        voteMgr.resetLocal();
      }

      // --- –ê–í–¢–û-–û–ë–ù–û–í–õ–ï–ù–ò–Ø ---
      setInterval(() => voteMgr && voteMgr.load(), 2000);
      setInterval(async () => {
        if (!mapMgr) return;
        const url = `${BASE_URL}/rest/v1/current_position?city=eq.${selectedCity}&select=lat,lng,heading&limit=1`;
        const response = await fetch(url, { headers: { apikey: API_KEY } });
        const data = await response.json();
        if (data.length) {
          const { lat, lng, heading } = data[0];
          const current = mapMgr.getPosition();
          if (
            Math.abs(current.lat - lat) > 1e-6 ||
            Math.abs(current.lng - lng) > 1e-6 ||
            Math.abs(current.heading - heading) > 1e-2
          ) {
            mapMgr.street.setPosition({ lat, lng });
            mapMgr.street.setPov({ heading, pitch: 0 });
            // –¥–æ–±–∞–≤–∏—Ç—å –≤ –º–∞—Ä—à—Ä—É—Ç
            if (!routeHistory.length || Math.abs(lat-routeHistory[routeHistory.length-1].lat)>1e-6 || Math.abs(lng-routeHistory[routeHistory.length-1].lng)>1e-6)
              routeHistory.push({lat, lng});
            mapMgr.drawRoute();
          }
        }
      }, 2000);
    }
  </script>
</body>
</html>

