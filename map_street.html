<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <title>TonRoad Street View</title>
  <meta name="viewport" content="width=device-width,initial-scale=1.0" />
  <style>
    html, body { margin:0; padding:0; height:100%; font-family:Arial,sans-serif; background:#2c3e50; color:#ecf0f1; }
    #mapWrap { width: 100%; position: fixed; top: 0; left: 0; z-index: 2000; display:none; }
    #mapHeaderBtn { position:absolute; top:10px; left:50%; transform:translateX(-50%); z-index:2100; background:#2ecc71; color:#000; font-size:28px; border-radius:30px; padding:20px 40px; border:none; cursor:pointer; }
    #map { height:30vh; width:100vw; }
    #street-view { height:70vh; width:100vw; position:relative; margin-top:0; }
    .mode-label, #citySelect, #voteResults, #timerLabel { position:absolute; z-index:1002; }
    .mode-label { top:10px; left:10px; background:red; color:#fff; padding:5px 10px; border-radius:4px; cursor:pointer; }
    #citySelect { top:10px; right:10px; padding:5px; background:#294; color:#fff; font-size:18px; border-radius:5px; }
    #voteResults { top:50px; left:10px; background:rgba(0,0,0,0.7); padding:5px 10px; border-radius:4px; }
    #timerLabel { bottom:150px; right:10px; font-size:18px; background:#222; color:#fff; border-radius:4px; padding:7px 12px; }
    .vote-buttons, .action-buttons { width:100vw; display:flex; justify-content:center; gap:12px; margin:0; }
    .vote-buttons { position:fixed; bottom:80px; left:0; z-index:1002; }
    .vote-buttons button { flex:1; font-size:22px; margin:0 2px; border-radius:8px; padding:15px 0; background:#223a56; color:#fff; border:none; }
    .action-buttons { position:fixed; bottom:15px; left:0; z-index:1002; }
    .action-buttons button, .action-buttons a { flex:1; font-size:22px; margin:0 2px; border-radius:8px; padding:15px 0; border:none; }
    #startButton { background:#2980b9; color:#fff; }
    #driveButton { background:#27ae60; color:#fff; }
    #backButton { background:#e67e22; color:#fff; }
    #radioButton { background:#14a3ee; color:#fff; text-decoration:none; display:flex; align-items:center; justify-content:center;}
    #radioButton span { margin-left:8px; font-size:20px;}
    /* –î–ª—è —Ç–µ–º–Ω–æ–≥–æ Telegram –Ω–∞ –º–æ–±–∏–ª–µ */
    body, #street-view, #mapWrap { background:#2c3e50; }
    /* –ú–∞—Ä—à—Ä—É—Ç */
    #mapRouteCanvas { position:absolute; pointer-events:none; z-index:3000; }
    /* –°–∫—Ä–æ–π "–ö–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã", "–ö—É–¥–∞ –ø–æ–µ–¥–µ–º" */
    #coordsDisplay, #nextCoordsDisplay { display:none; }
  </style>
  <script src="https://telegram.org/js/telegram-web-app.js"></script>
  <script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyDLtao0F3Xm136OwD-LFglwhpBdOB6sht8" async defer></script>
</head>
<body>
  <div id="modeLabel" class="mode-label">–†–µ–∂–∏–º: –ì–æ–ª–æ—Å–æ–≤–∞–Ω–∏–µ</div>
  <select id="citySelect">
    <option value="Berlin">–ë–µ—Ä–ª–∏–Ω</option>
    <option value="Leipzig">–õ–µ–π–ø—Ü–∏–≥</option>
    <option value="Dresden">–î—Ä–µ–∑–¥–µ–Ω</option>
    <option value="Novorossiysk">–ù–æ–≤–æ—Ä–æ—Å—Å–∏–π—Å–∫</option>
  </select>
  <div id="voteResults">–í–ª–µ–≤–æ: 0 | –ü—Ä—è–º–æ: 0 | –í–ø—Ä–∞–≤–æ: 0</div>
  <span id="timerLabel" style="display:none"></span>
  <!-- –í—Å–ø–ª—ã–≤–∞—é—â–∞—è –∫–∞—Ä—Ç–∞ -->
  <div id="mapWrap">
    <button id="mapHeaderBtn">–°–∫—Ä—ã—Ç—å –∫–∞—Ä—Ç—É ‚ñ≤</button>
    <div id="map"></div>
  </div>
  <div id="street-view"></div>
  <div class="vote-buttons">
    <button data-dir="left">‚Üê –í–ª–µ–≤–æ</button>
    <button data-dir="straight">‚Üë –ü—Ä—è–º–æ</button>
    <button data-dir="right">‚Üí –í–ø—Ä–∞–≤–æ</button>
  </div>
  <div class="action-buttons">
    <button id="startButton">–°—Ç–∞—Ä—Ç</button>
    <button id="driveButton">–ï–•–ê–¢–¨</button>
    <button id="backButton">–ù–∞–∑–∞–¥</button>
    <a id="radioButton" href="https://t.me/fmusbot" target="_blank"> <span>üéµ –†–∞–¥–∏–æ</span></a>
  </div>
  <!-- —Å–∫—Ä—ã—Ç—ã–µ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã -->
  <div id="coordsDisplay"></div>
  <div id="nextCoordsDisplay"></div>

  <script>
    // --- CONFIG ---
    const API_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InFzZGFvb3h5d3pubG9vZ3loZXl1Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTIwMDAyMzIsImV4cCI6MjA2NzU3NjIzMn0.t2wjdhhV_RfaB3aVQqDai546h5xNNBZpEu_lnrkL8Do";
    const BASE_URL = "https://qsdaooxywznloogyheyu.supabase.co";
    // ID –≤–µ–¥—É—â–µ–≥–æ ‚Äî —Ç–æ–ª—å–∫–æ —É –Ω–µ–≥–æ –∫–Ω–æ–ø–∫–∏ "–°—Ç–∞—Ä—Ç" –∏ "–ï–•–ê–¢–¨"
    const HOST_ID = "5959529178";

    // --- STATE ---
    let routePath = [];
    let currentUserId = null;
    let app = null;
    // --- END ---

    // –ü–æ–ª—É—á–∞–µ–º Telegram user_id –¥–ª—è –≤–µ–¥—É—â–µ–≥–æ
    function getTelegramId() {
      try {
        if (window.Telegram && Telegram.WebApp && Telegram.WebApp.initDataUnsafe) {
          return Telegram.WebApp.initDataUnsafe.user && Telegram.WebApp.initDataUnsafe.user.id ? Telegram.WebApp.initDataUnsafe.user.id.toString() : null;
        }
      } catch (e) { return null; }
      return null;
    }

    window.onload = () => {
      Telegram.WebApp.ready();
      currentUserId = getTelegramId();
      // –°–∫—Ä—ã–≤–∞–µ–º –∫–Ω–æ–ø–∫–∏ "–ï–•–ê–¢–¨" –∏ "–°—Ç–∞—Ä—Ç" –µ—Å–ª–∏ –Ω–µ –≤–µ–¥—É—â–∏–π
      setTimeout(() => {
        if (currentUserId !== HOST_ID) {
          document.getElementById('driveButton').style.display = "none";
          document.getElementById('startButton').style.display = "none";
        }
      }, 500);
      initApp();
    };

    function initApp() {
      let timer = null;
      let timerValue = 5;
      let timerActive = false;

      class MapManager {
        constructor(mapEl, streetEl, cities) {
          this.cities = cities;
          this.routePolyline = null;
          this.panorama = new google.maps.StreetViewPanorama(streetEl, {
            position: cities.Berlin,
            pov: { heading: 0, pitch: 0 },
            visible: true
          });
          this.map = new google.maps.Map(mapEl, {
            center: cities.Berlin,
            zoom: 14,
            mapTypeId: "roadmap"
          });
          this.map.setStreetView(this.panorama);
        }

        setCity(cityKey) {
          const pos = this.cities[cityKey];
          this.map.setCenter(pos);
          this.panorama.setPosition(pos);
        }

        setInteraction(enabled) {
          this.panorama.setOptions({
            clickToGo: enabled,
            linksControl: enabled
          });
        }

        getPosition() {
          const pos = this.panorama.getPosition();
          const heading = this.panorama.getPov().heading;
          return { lat: pos.lat(), lng: pos.lng(), heading };
        }

        async loadPositionFromServer(city) {
          const url = `${BASE_URL}/rest/v1/current_position?city=eq.${city}&select=lat,lng,heading&limit=1`;
          const response = await fetch(url, { headers: { apikey: API_KEY } });
          const data = await response.json();
          if (data.length) {
            const { lat, lng, heading } = data[0];
            this.panorama.setPosition({ lat, lng });
            this.panorama.setPov({ heading, pitch: 0 });
            // –î–æ–±–∞–≤–ª—è–µ–º –≤ –º–∞—Ä—à—Ä—É—Ç (–µ—Å–ª–∏ –ø—É—Å—Ç–æ –∏–ª–∏ —Ç–æ—á–∫–∞ –Ω–µ —Å–æ–≤–ø–∞–¥–∞–µ—Ç)
            if (!routePath.length || routePath[routePath.length-1].lat !== lat || routePath[routePath.length-1].lng !== lng) {
              routePath.push({lat, lng});
              this.drawRoute();
            }
          }
        }

        async savePositionToServer(city) {
          const pos = this.getPosition();
          await fetch(`${BASE_URL}/rest/v1/current_position?city=eq.${city}`, {
            method: "PATCH",
            headers: {
              apikey: API_KEY,
              "Content-Type": "application/json"
            },
            body: JSON.stringify({ lat: pos.lat, lng: pos.lng, heading: pos.heading })
          });
        }

        findBestLink(dir) {
          const pov = this.panorama.getPov().heading;
          const links = this.panorama.getLinks() || [];
          const want = { straight: 0, left: 270, right: 90 }[dir];
          let best = { diff: Infinity, link: null };
          links.forEach(link => {
            let rel = (link.heading - pov + 360) % 360;
            let diff = Math.abs(rel - want);
            diff = Math.min(diff, 360 - diff);
            if (diff < best.diff) best = { diff, link };
          });
          if (!best.link) throw new Error('–ù–µ—Ç –ø–æ–¥—Ö–æ–¥—è—â–µ–≥–æ –ø–æ–≤–æ—Ä–æ—Ç–∞');
          return best.link;
        }

        async saveNextPositionToServer(city, dir) {
          try {
            const link = this.findBestLink(dir);
            const svService = new google.maps.StreetViewService();
            svService.getPanorama({ pano: link.pano }, async (data, status) => {
              if (status === google.maps.StreetViewStatus.OK) {
                const nextLatLng = data.location.latLng;
                await fetch(`${BASE_URL}/rest/v1/current_position?city=eq.${city}`, {
                  method: "PATCH",
                  headers: {
                    apikey: API_KEY,
                    "Content-Type": "application/json",
                  },
                  body: JSON.stringify({
                    next_lat: nextLatLng.lat(),
                    next_lng: nextLatLng.lng(),
                    next_heading: link.heading
                  })
                });
              }
            });
          } catch (e) {}
        }

        async loadNextPositionFromServer(city) {
          const url = `${BASE_URL}/rest/v1/current_position?city=eq.${city}&select=next_lat,next_lng,next_heading&limit=1`;
          const response = await fetch(url, { headers: { apikey: API_KEY } });
          const data = await response.json();
          if (data.length && data[0].next_lat && data[0].next_lng && data[0].next_heading !== undefined) {
            return {
              lat: data[0].next_lat,
              lng: data[0].next_lng,
              heading: data[0].next_heading
            };
          }
          return null;
        }

        async goToNextPosition(city) {
          const next = await this.loadNextPositionFromServer(city);
          if (!next) return false;
          this.panorama.setPosition({ lat: next.lat, lng: next.lng });
          this.panorama.setPov({ heading: next.heading, pitch: 0 });
          // –î–æ–±–∞–≤–∏—Ç—å –≤ –º–∞—Ä—à—Ä—É—Ç –Ω–æ–≤—É—é —Ç–æ—á–∫—É
          if (!routePath.length || routePath[routePath.length-1].lat !== next.lat || routePath[routePath.length-1].lng !== next.lng) {
            routePath.push({lat: next.lat, lng: next.lng});
            this.drawRoute();
          }
          await fetch(`${BASE_URL}/rest/v1/current_position?city=eq.${city}`, {
            method: "PATCH",
            headers: {
              apikey: API_KEY,
              "Content-Type": "application/json"
            },
            body: JSON.stringify({
              lat: next.lat,
              lng: next.lng,
              heading: next.heading
            })
          });
          return true;
        }

        async resetToStart(city) {
          const pos = this.cities[city];
          this.panorama.setPosition(pos);
          this.panorama.setPov({ heading: 0, pitch: 0 });
          routePath = [pos];
          this.drawRoute();
          await fetch(`${BASE_URL}/rest/v1/current_position?city=eq.${city}`, {
            method: "PATCH",
            headers: {
              apikey: API_KEY,
              "Content-Type": "application/json"
            },
            body: JSON.stringify({ lat: pos.lat, lng: pos.lng, heading: 0 })
          });
        }

        // –†–∏—Å—É–µ–º –º–∞—Ä—à—Ä—É—Ç (polyline)
        drawRoute() {
          if (!window.google || !this.map) return;
          if (this.routePolyline) {
            this.routePolyline.setMap(null);
            this.routePolyline = null;
          }
          if (routePath.length >= 2) {
            this.routePolyline = new google.maps.Polyline({
              path: routePath,
              geodesic: true,
              strokeColor: "#ff2222",
              strokeOpacity: 1.0,
              strokeWeight: 6
            });
            this.routePolyline.setMap(this.map);
          }
        }
      }

      class VoteManager {
        constructor(city, mode, displayEl, onVoteChange) {
          this.city = city;
          this.mode = mode;
          this.displayEl = displayEl;
          this.votes = { left: 0, straight: 0, right: 0 };
          this.onVoteChange = onVoteChange;
        }

        async load() {
          const url = `${BASE_URL}/rest/v1/votes_summary?select=direction,count&city=eq.${this.city}&mode=eq.${this.mode}`;
          const res = await fetch(url, { headers: { apikey: API_KEY } });
          const data = await res.json();
          this.votes = { left: 0, straight: 0, right: 0 };
          data.forEach(v => this.votes[v.direction] = v.count);
          this.updateDisplay();
          if (this.onVoteChange) this.onVoteChange(this.votes);
        }

        async vote(dir) {
          this.votes[dir]++;
          this.updateDisplay();
          if (this.onVoteChange) this.onVoteChange(this.votes);
          await fetch(`${BASE_URL}/functions/v1/cast_vote-ts`, {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              apikey: API_KEY,
              Authorization: `Bearer ${API_KEY}`
            },
            body: JSON.stringify({ city: this.city, mode: this.mode, direction: dir })
          });
        }

        async resetOnServer() {
          await fetch(`${BASE_URL}/rest/v1/votes_summary?city=eq.${this.city}&mode=eq.${this.mode}`, {
            method: "PATCH",
            headers: {
              apikey: API_KEY,
              "Content-Type": "application/json"
            },
            body: JSON.stringify({ count: 0 })
          });
        }

        updateDisplay() {
          this.displayEl.textContent = `–í–ª–µ–≤–æ: ${this.votes.left} | –ü—Ä—è–º–æ: ${this.votes.straight} | –í–ø—Ä–∞–≤–æ: ${this.votes.right}`;
        }

        resetLocal() {
          this.votes = { left: 0, straight: 0, right: 0 };
          this.updateDisplay();
        }
      }

      class AppController {
        constructor() {
          this.cities = {
            Berlin: { lat: 52.52, lng: 13.405 },
            Leipzig: { lat: 51.3397, lng: 12.3731 },
            Dresden: { lat: 51.0504, lng: 13.7373 },
            Novorossiysk: { lat: 44.7236, lng: 37.7689 }
          };
          this.mode = "voting";
          this.mapMgr = new MapManager(document.getElementById('map'), document.getElementById('street-view'), this.cities);
          const city = localStorage.getItem("selectedCity") || "Berlin";
          this.voteMgr = new VoteManager(city, this.mode, document.getElementById('voteResults'), (votes) => this.handleVoteChange(votes));
          this.mapMgr.loadPositionFromServer(city);
          this.voteMgr.load();
          this.updateNextCoordsDisplay(city);
          this.timerValue = 0;
          this.timerActive = false;
          this.timerInterval = null;
          this.setupUI();
        }

        setupUI() {
          document.getElementById('citySelect').value = this.voteMgr.city;
          document.getElementById('citySelect').addEventListener('change', async e => {
            this.voteMgr.city = e.target.value;
            localStorage.setItem("selectedCity", e.target.value);
            await this.mapMgr.loadPositionFromServer(e.target.value);
            await this.voteMgr.load();
            await this.updateNextCoordsDisplay(e.target.value);
            this.mapMgr.map.setCenter(this.mapMgr.cities[e.target.value]);
            // –°–±—Ä–æ—Å –º–∞—Ä—à—Ä—É—Ç–∞
            routePath = [];
            this.mapMgr.drawRoute();
            this.resetTimer();
          });

          document.querySelectorAll('.vote-buttons button').forEach(btn =>
            btn.addEventListener('click', () => this.voteMgr.vote(btn.dataset.dir))
          );

          document.getElementById('driveButton').addEventListener('click', () => this.drive());
          document.getElementById('startButton').addEventListener('click', async () => {
            await this.mapMgr.resetToStart(this.voteMgr.city);
            this.voteMgr.resetLocal();
            this.updateNextCoordsDisplay(this.voteMgr.city);
            this.resetTimer();
          });

          // –ö–Ω–æ–ø–∫–∞ "–ù–∞–∑–∞–¥" ‚Äî –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –∫–∞—Ä—Ç—É
          document.getElementById('backButton').addEventListener('click', () => {
            showMap();
          });

          // –ö–Ω–æ–ø–∫–∞ –∫–∞—Ä—Ç—ã (–ø–æ–∫–∞–∑–∞—Ç—å/—Å–∫—Ä—ã—Ç—å)
          document.getElementById('mapHeaderBtn').addEventListener('click', () => {
            hideMap();
          });

          // –û—Ç–∫—Ä—ã–≤–∞—Ç—å –∫–∞—Ä—Ç—É —Å–≤–∞–π–ø–æ–º –∏–ª–∏ –ø–æ —Ç–∞–ø—É –ø–æ StreetView ‚Äî –æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ
          document.getElementById('modeLabel').addEventListener('click', showMap);
        }

        async handleVoteChange(votes) {
          const total = Object.values(votes).reduce((a, b) => a + b, 0);
          if (total === 0) {
            this.resetTimer();
            return;
          }
          const maxDir = Object.keys(votes).reduce((a, b) => votes[a] > votes[b] ? a : b);
          await this.mapMgr.saveNextPositionToServer(this.voteMgr.city, maxDir);
          await this.updateNextCoordsDisplay(this.voteMgr.city);

          // –ï—Å–ª–∏ —Ç–∞–π–º–µ—Ä –Ω–µ –±—ã–ª –∞–∫—Ç–∏–≤–µ–Ω ‚Äî —Å—Ç–∞—Ä—Ç—É–µ–º!
          if (!this.timerActive) {
            this.startTimer();
          }
        }

        startTimer() {
          this.timerValue = 5;
          this.timerActive = true;
          document.getElementById('timerLabel').style.display = "";
          document.getElementById('timerLabel').textContent = `–ü–æ–µ–¥–µ–º —á–µ—Ä–µ–∑: ${this.timerValue} —Å–µ–∫`;
          this.timerInterval = setInterval(() => {
            this.timerValue--;
            document.getElementById('timerLabel').textContent = `–ü–æ–µ–¥–µ–º —á–µ—Ä–µ–∑: ${this.timerValue} —Å–µ–∫`;
            if (this.timerValue <= 0) {
              this.drive();
            }
          }, 1000);
        }

        resetTimer() {
          if (this.timerInterval) clearInterval(this.timerInterval);
          this.timerActive = false;
          this.timerValue = 0;
          document.getElementById('timerLabel').style.display = "none";
        }

        async updateNextCoordsDisplay(city) {
          // –û—Ç–∫–ª—é—á–µ–Ω–æ: "–ö—É–¥–∞ –ø–æ–µ–¥–µ–º"
          document.getElementById('nextCoordsDisplay').textContent = "";
        }

        async drive() {
          this.resetTimer();
          const moved = await this.mapMgr.goToNextPosition(this.voteMgr.city);
          if (!moved) {
            this.voteMgr.displayEl.textContent = '–ù–µ—Ç –±—É–¥—É—â–µ–π –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –¥–ª—è –¥–≤–∏–∂–µ–Ω–∏—è';
            return;
          }
          this.voteMgr.displayEl.textContent = `–ü–æ–µ—Ö–∞–ª–∏!`;
          await this.voteMgr.resetOnServer();
          this.voteMgr.resetLocal();
          await this.updateNextCoordsDisplay(this.voteMgr.city);
        }
      }

      // --- –í—Å–ø–ª—ã–≤–∞—é—â–∞—è –∫–∞—Ä—Ç–∞ ---
      function showMap() {
        document.getElementById('mapWrap').style.display = '';
        document.body.style.overflow = 'hidden';
      }
      function hideMap() {
        document.getElementById('mapWrap').style.display = 'none';
        document.body.style.overflow = '';
      }

      app = new AppController();

      // –ê–≤—Ç–æ–æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –≥–æ–ª–æ—Å–æ–≤, –º–∞—Ä—à—Ä—É—Ç–∞ –∏ —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è –ø–æ–∑–∏—Ü–∏–∏ —Ä–∞–∑ –≤ 2 —Å–µ–∫
      setInterval(() => app.voteMgr.load(), 2000);

      setInterval(async () => {
        const city = app.voteMgr.city;
        const url = `${BASE_URL}/rest/v1/current_position?city=eq.${city}&select=lat,lng,heading&limit=1`;
        const response = await fetch(url, { headers: { apikey: API_KEY } });
        const data = await response.json();
        if (data.length) {
          const { lat, lng, heading } = data[0];
          const current = app.mapMgr.getPosition();
          if (
            Math.abs(current.lat - lat) > 1e-6 ||
            Math.abs(current.lng - lng) > 1e-6 ||
            Math.abs(current.heading - heading) > 1e-2
          ) {
            app.mapMgr.panorama.setPosition({ lat, lng });
            app.mapMgr.panorama.setPov({ heading, pitch: 0 });
            // –í –º–∞—Ä—à—Ä—É—Ç –¥–æ–±–∞–≤–ª—è–µ–º
            if (!routePath.length || routePath[routePath.length-1].lat !== lat || routePath[routePath.length-1].lng !== lng) {
              routePath.push({lat, lng});
              app.mapMgr.drawRoute();
            }
          }
        }
      }, 2000);

    }
  </script>
</body>
</html>

